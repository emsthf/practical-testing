# 실용적인 스프링부트 테스트
## 요구사항
- 주문 목록에 음료 추가/삭제 기능
- 주문 목록 전체 지우기
- 주문 목록 총 금액 계산하기
- 주문 생성하기

### 추가 요구사항
```
이러한 추가 요구사항이 올 때에는 기획자에게 구현할 때 암묵적이거나 드러나지 않은 요구사항이 있는지 물어보는 것이 좋다.
```
- 한 종류의 음료 여러 잔을 한번에 담는 기능(수량 조절)
- 가게 운영 시간(10:00~ 22:00)에만 주문이 가능하도록 하기

## 자동화 테스트
### 단위 테스트
- 작은 코드 단위(클래스 or 메서드)를 독립적으로 검증하는 테스트
- 다른 테스트에 비해 검증 속도가 빠르고, 안정적이다.
- JUnit5(Java의 테스트 라이브러리), AssertJ(풍부한 API, 메서드 체이닝 지원) 사용

### 테스트 케이스 세분화 하기
- 해피 케이스
- 예외 케이스  
```
음료 숫자를 0이나 음수를 입력한다던지...
```
이러한 케이스를 테스트 할 때 주의해야 할 것이 **경계값 테스트**
- 범위(이상, 이하, 초과, 미만), 구간, 날짜 등
- 예를들어 3 이상의 조건을 테스트 할 때, 해피 케이스로 3을 넣고, 예외 케이스로 2를 넣어 테스트 할 수 있다.

### 테스트하기 어려운 영역을 구분하고 분리하기
테스트 가능한 영역에 테스트 하기 어려운 코드가 들어오게 되면 전체가 테스트하기 어려워 진다.
![img.png](img/testable_area.png)
이렇게 해도 되는가??
- 예를 들어 createOrder() 메서드 내부에서 현재 시간을 사용한다면 테스트하기 어렵다. 같은 테스트라도 현재 시간에 따라 실패할 수도, 성공할 수도 있기 때문
- 이럴 때는 테스트 하기 어려운 영역을 외부로 분리하면 된다. createOrder() 메서드의 파라미터로 LocalDateTime을 받도록 하면 테스트가 용이해진다.
```
우리가 테스트하고자 하는 부분은 LocalDateTime이 아니다. 어떤 시간이 주어졌을 때 조건을 판단하는게 중요한 것!
테스트 코드 상에서 원하는 값을 넣어줄 수 있도록 설계를 변경하는 것이 중요하다.
```
**외부로 분리할 수록 테스트 가능한 코드는 많아진다.**
<br>
어느 단계까지 분리해야 하는가는 판단을 해야한다.

### 테스트하기 어려운 영역
- 관측할 때마다 다른 값에 의존하는 코드(현재 날짜/시간, 랜덤 값, 변수/함수, 사용자 입력 등)
- 외부 세계에 영향을 주는 코드(표준 출력, 메시지 발송, 데이터베이스에 기록하기 등)

### 테스트하기 쉬운 영역
순수함수
- 같은 입력에는 항상 같은 결과
- 외부 세상과 단절된 형태
- 테스트하기 쉬운 코드

### 📌 Lombok 사용 가이드
롬복은 사용하는 방법을 잘 알고 쓰는게 중요하다. 남발하면 유지보수하기 어려운 코드가 되기 때문.<br>
**@Data, @Setter, @AllArgsConstructor** 지양
- @AllArgsConstructor는 모든 필드를 초기화하는 생성자를 만들기 때문에 필요하지 않은 필드에도 값을 주입해야 한다. 불완전한 객체를 테스트하기 힘들어지므로 @AllArgsConstructor 대신 @RequiredArgsConstructor를 사용하자.
- @Data, @Setter를 사용하면 모든 필드를 변경할 수 있게 된다. 이는 객체의 불변성을 해치며 예기치 않은 사이드 이펙트를 유발할 수 있다.

@ToString은 가급적 DTO에만 사용(JPA 양방향 연관관계 시 순환 참조문제가 발생할 수 있기 때문)
